# -*- coding: utf-8 -*-
"""Honors Contract

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14Y6_gaL8n3l_BObEG7ehpgzBwZ6c3Q1A

$\psi(x,t)=\frac{1}{2}\psi_1+\frac{1}{\sqrt{2}}\psi_2+\frac{1}{2}\psi_3$

#Time-dependent wavefunction separated into real and imaginary components
"""

# Code adapted from https://stackoverflow.com/questions/38118598/how-to-create-a-3d-animation

from matplotlib import pyplot as plt
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import animation
from matplotlib import rc       # these lines needed to run it on Colab
rc('animation', html = 'jshtml')  # these lines needed to run it on Colab
import matplotlib
matplotlib.rcParams['animation.embed_limit'] = 2**128

fig = plt.figure(figsize = (10, 5))
ax1 = fig.add_subplot(1, 2, 1, xticks = [], yticks = [], projection = '3d')
ax2 = fig.add_subplot(1, 2, 2, xticks = [], yticks = [], projection = '3d')

def create(frames):
    a = 1.0
    x_min = 0.0
    x_max = a
    x = np.linspace(x_min, x_max, 100)
    y_and_z = np.zeros((2*frames, 100))
    time_step = 0.02

    for j in np.arange(0, 2*frames):
      for i in np.arange(0, 100):
        omega1 = 1
        omega2 = 4
        omega3 = 9

        wiggle1 = np.exp(-1.0j*omega1*j*time_step)
        wiggle2 = np.exp(-1.0j*omega2*j*time_step)
        wiggle3 = np.exp(-1.0j*omega3*j*time_step)

        if j % 2 == 0:
          y_and_z[j, i] = np.real(0.5*np.sqrt(2/a)*np.sin(1*np.pi*x[i]/a)*wiggle1 + (1/np.sqrt(2))*np.sqrt(2/a)*np.sin(2*np.pi*x[i]/a)*wiggle2 + 0.5*np.sqrt(2/a)*np.sin(3*np.pi*x[i]/a)*wiggle3)
        else:
          y_and_z[j, i] = np.imag(0.5*np.sqrt(2/a)*np.sin(1*np.pi*x[i]/a)*wiggle1 + (1/np.sqrt(2))*np.sqrt(2/a)*np.sin(2*np.pi*x[i]/a)*wiggle2 + 0.5*np.sqrt(2/a)*np.sin(3*np.pi*x[i]/a)*wiggle3)

    return(x, y_and_z)

def update(frame_num, y_and_z, line, line_real, line_imag):
    z = y_and_z[2*frame_num, :]
    y = y_and_z[2*frame_num + 1, :]
    x_and_y = np.vstack((x, y))
    x_and_y_real = np.vstack((x, np.zeros(100)))
    line.set_data(x_and_y)
    line.set_3d_properties(z)
    line_real.set_data(x_and_y_real)
    line_real.set_3d_properties(z)
    line_imag.set_data(x_and_y)
    line_imag.set_3d_properties(np.zeros(100))

frames = 200
x, y_and_z = create(frames)
line, = ax1.plot(x, y_and_z[1, :], y_and_z[0, :], c = 'b', label = 'complex')
line_real, = ax2.plot(x, y_and_z[1, :], y_and_z[0, :], c = 'cyan', linestyle = '--', label = 'real')
line_imag, = ax2.plot(x, y_and_z[1, :], y_and_z[0, :], c = 'orange', linestyle = '--', label = 'imaginary')

# Setting the axes properties
ax1.set_xlim3d([0.0, 1.0])
ax1.set_xlabel('Real $x$')
ax1.set_ylim3d([-2.0, 2.0])
ax1.set_ylabel('Imaginary $y$')
ax1.set_zlim3d([-2.0, 2.0])
ax1.set_zlabel('Real $y$')
ax1.set_title('$\psi(x,t)$')
ax1.legend(loc = 'upper right')

ax2.set_xlim3d([0.0, 1.0])
ax2.set_xlabel('Real $x$')
ax2.set_ylim3d([-2.0, 2.0])
ax2.set_ylabel('Imaginary $y$')
ax2.set_zlim3d([-2.0, 2.0])
ax2.set_zlabel('Real $y$')
ax2.set_title('$\psi(x,t)$')
ax2.legend(loc = 'upper right')

ani = animation.FuncAnimation(fig, update, frames, fargs = (y_and_z, line, line_real, line_imag), interval = 40, blit = False)
ani

"""#Time-dependent wavefunction with color map to indicate phase"""

from matplotlib import pyplot as plt
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import animation
from matplotlib import rc       # these lines needed to run it on Colab
rc('animation', html = 'jshtml')  # these lines needed to run it on Colab
from matplotlib.patches import PathPatch
import matplotlib
matplotlib.rcParams['animation.embed_limit'] = 2**128

cmap = plt.get_cmap('hsv')
fig = plt.figure(figsize = (10, 5))
ax1 = fig.add_subplot(1, 2, 1)
ax2 = fig.add_subplot(1, 2, 2)

def create(frames):
    a = 1.0
    m = 2.0
    x_min = 0.0
    x_max = a

    x = np.linspace(x_min, x_max, 200)
    y_all_frames = np.zeros((frames, 200))
    psi_all_frames = np.zeros((frames, 200)).astype(np.complex128)
    prob_all_frames = np.zeros((frames, 200))
    phase_all_frames = np.zeros((frames, 200))
    time_step = 0.005

    for j in np.arange(0, frames):
      for i in np.arange(0, 200):
        omega_x_1 = m**2
        wiggle_x_1 = np.exp(-1.0j*omega_x_1*j*time_step)
        omega_x_2 = (m + 1)**2
        wiggle_x_2 = np.exp(-1.0j*omega_x_2*j*time_step)
        omega_x_3 = (m + 2)**2
        wiggle_x_3 = np.exp(-1.0j*omega_x_3*j*time_step)

        psi_1 = np.sqrt(1/a*np.sqrt(2))*np.sin(m*np.pi*x[i]/a)*wiggle_x_1
        psi_2 = np.sqrt(1/a*2)*np.sin((m + 1)*np.pi*x[i]/a)*wiggle_x_2
        psi_3 = np.sqrt(1/a*np.sqrt(2))*np.sin((m + 2)*np.pi*x[i]/a)*wiggle_x_3

        psi_all_frames[j, i] = (psi_1 + psi_2 + psi_3)

        y_all_frames[j, i] = np.real(psi_all_frames[j, i])

        prob_all_frames[j, i] = np.real_if_close(np.conjugate(psi_all_frames[j, i])*psi_all_frames[j, i])
        phase_all_frames[j, i] = np.angle(psi_all_frames[j, i])

    return(x, y_all_frames, prob_all_frames, phase_all_frames)

def update(frame_num, x, y_all_frames, prob_all_frames, phase_all_frames, line1, line2):
    y = y_all_frames[frame_num, :]
    x_and_y = np.vstack((x, y))
    line1.set_data(x_and_y)

    prob = prob_all_frames[frame_num, :]
    x_and_prob = np.vstack((x, prob))

    ax2.clear()
    ax2.set_ylim(0, 4)
    line2.set_data(x_and_prob)

    poly = ax2.fill_between(x, 0, prob, color = 'none')
    img = ax2.imshow(np.hstack((np.array([-np.pi]), phase_all_frames[frame_num, 1:100], np.array([np.pi]))).reshape(1, -1), extent = [x[0], x[-1], 0, prob.max()], cmap = cmap, aspect = 'auto')
    clip_poly = PathPatch(poly.get_paths()[0], transform = ax2.transData)
    img.set_clip_path(clip_poly)

frames = 200
x, y_all_frames, prob_all_frames, phase_all_frames = create(frames)
line1, = ax1.plot(x, y_all_frames[0, :])
line2, = ax2.plot(x, prob_all_frames[0, :])

poly = ax2.fill_between(x, 0, prob_all_frames[0, :], color = 'none')
img = ax2.imshow(np.hstack((np.array([-np.pi]), phase_all_frames[0, 1:200], np.array([np.pi]))).reshape(1, -1), extent = [x[0], x[-1], 0, prob_all_frames[0, :].max()], cmap = cmap, aspect = 'auto')
clip_poly = PathPatch(poly.get_paths()[0], transform = ax2.transData)
img.set_clip_path(clip_poly)

# Setting the axes properties
ax1.set_xlim([0.0, 1.0])
ax1.set_ylim([-3.0, 3.0])

ax2.set_xlim([0.0, 1.0])
ax2.set_ylim([0.0, 4.0])

ani = animation.FuncAnimation(fig, update, frames, fargs = (x, y_all_frames, prob_all_frames, phase_all_frames, line1, line2), interval = 40, blit = False)
ani

"""#2d wavefunction bound to an infinite square well"""

from matplotlib import pyplot as plt
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import animation
from matplotlib import rc       # these lines needed to run it on Colab
rc('animation', html = 'jshtml')  # these lines needed to run it on Colab
from matplotlib.patches import PathPatch
import matplotlib
matplotlib.rcParams['animation.embed_limit'] = 2**128

cmap = plt.get_cmap('hsv')
fig = plt.figure(figsize = (5, 5))
ax = fig.add_subplot()

def update(frame_num):
    ax.clear()

    a = 1.0
    b = 1.0
    m = 2.0
    n = 4.0

    x_min = 0.0
    x_max = a
    y_min = 0.0
    y_max = b

    time_step = 0.005

    x = np.linspace(x_min, x_max, 50)
    y = np.linspace(y_min, y_max, 50)
    psi = np.zeros((50, 50))

    for i in np.arange(0, 50):
      for k in np.arange(0, 50):
        omega_x_1 = m**2
        wiggle_x_1 = np.exp(-1.0j*omega_x_1*frame_num*time_step)
        omega_x_2 = (m + 1)**2
        wiggle_x_2 = np.exp(-1.0j*omega_x_2*frame_num*time_step)
        omega_x_3 = (m + 2)**2
        wiggle_x_3 = np.exp(-1.0j*omega_x_3*frame_num*time_step)
        omega_y_1 = n**2
        wiggle_y_1 = np.exp(-1.0j*omega_y_1*frame_num*time_step)
        omega_y_2 = (n + 1)**2
        wiggle_y_2 = np.exp(-1.0j*omega_y_2*frame_num*time_step)
        omega_y_3 = (n + 2)**2
        wiggle_y_3 = np.exp(-1.0j*omega_y_3*frame_num*time_step)


        psi1 = (1/np.sqrt(2*a*b))*np.sin(m*np.pi*x[i]/a)*wiggle_x_1*np.sin(n*np.pi*y[k]/b)*wiggle_y_1
        psi2 = (1/np.sqrt(a*b))*np.sin((m + 1)*np.pi*x[i]/a)*wiggle_x_2*np.sin((n + 1)*np.pi*y[k]/b)*wiggle_y_2
        psi3 = (1/np.sqrt(2*a*b))*np.sin((m + 2)*np.pi*x[i]/a)*wiggle_x_3*np.sin((n + 2)*np.pi*y[k]/b)*wiggle_y_3

        psi[i, k] = np.real(psi1 + psi2 + psi3)

    img = ax.imshow(np.hstack((np.full((50, 1), -1.5), psi, np.full((50, 1), 1.5))), extent = [x[0], x[-1], y[0], y[-1]], cmap = cmap, aspect = 'auto')

frames = 200

# Setting the axes properties
ax.set_xlim([0.0, 1.0])
ax.set_ylim([0.0, 1.0])

ani = animation.FuncAnimation(fig, update, frames, interval = 40, blit = False)
ani