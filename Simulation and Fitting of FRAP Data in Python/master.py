# -*- coding: utf-8 -*-
"""Master.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NsAsjHiAw2wLnund3NPQ6swB9lHKU2qw

3.1

Title the python file on the top left (example: 5-27 FRAP 59b.ipynb).
Also move to the corresponding folder

Pre Bleach

3.2
"""

import tifffile as tif
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np
from google.colab import drive
from ipywidgets import widgets
from IPython.display import display
from matplotlib.path import Path
import os

base_dir = '/content/drive/Shared drives/SLB Studies/TIF Files'
folder_name = '6-25 FRAP 56a'  # You can change this value as needed

#Grab the image to use in the rest of analysis
drive.mount('/content/drive', force_remount=True)
file_name = f'{base_dir}/{folder_name}/1.tif'

"""3.3"""

#Define a function to analyze a circular region of an image
def analyze_circular_region(file_name, center, radius, show_plot=True):
    # Load image
    image = tif.imread(file_name)
    size = image.shape

    # Set up plot
    if show_plot:
        fig = plt.figure(figsize=(7, 7))
        ax = fig.add_subplot(111)
        ax.imshow(image, cmap='gray', vmin=0, vmax=5000)

        # Draw circle
        circle = patches.Circle(center, radius, edgecolor='r', facecolor='none')
        ax.add_patch(circle)
        ax.set_aspect('equal', adjustable='box')
        ax.invert_yaxis()
        plt.show()

    # Create circular mask
    y, x = np.ogrid[:size[0], :size[1]]
    mask = (x - center[0])**2 + (y - center[1])**2 <= radius**2

    # Mask image
    image_outside_circle = np.copy(image)
    image_outside_circle[~mask] = 0

    # Compute mean intensity inside the circle
    pixels_inside_circle = image[mask]
    intensity = np.mean(pixels_inside_circle)

    return intensity

"""3.4"""

#Grab the average intensity of a region of fluorescence
radius1 = 50
center1 = (470, 660)

max_intensity = analyze_circular_region(file_name, center1, radius1)

"""3.5"""

#Grab the average intensity of a region of Background
radius2 = 60
center2 = (880, 650)

min_intensity = analyze_circular_region(file_name, center2, radius2)

"""##Get center intensity

3.6
"""

tiny_radius = 4
spot_radius = 50
spot_center = (440, 355)

center_intensity = analyze_circular_region(file_name, spot_center, tiny_radius)

"""Post Bleach

3.7
"""

# Initialize an empty list to store the average values for each image
average_values = []
time = []

for i in np.arange(1, 60.5, 0.5):
    # Convert i to an integer if it's an integer value (i.e., .0)
    if i.is_integer():
        file_name = f'{base_dir}/{folder_name}/{int(i)}.tif'
    else:
        file_name = f'{base_dir}/{folder_name}/{i}.tif'

    if os.path.exists(file_name):
        image = tif.imread(file_name)
    else:
        continue

    # Get image size
    size = image.shape

    # Create a mask for the circular region
    y, x = np.ogrid[:size[0], :size[1]]  # Create coordinate grids for the image
    mask = (x - spot_center[0])**2 + (y - spot_center[1])**2 <= spot_radius**2  # Circular mask

    # Set all entries outside the circle to 0
    image_outside_circle = np.copy(image)
    image_outside_circle[~mask] = 0

    # Calculate the average value of the pixels inside the circle
    pixels_inside_circle = image[mask]  # Get the pixel values inside the circle
    average_value_inside_circle = np.mean(pixels_inside_circle)

    # Append the average value to the list
    average_values.append(average_value_inside_circle)
    time.append(i)

plt.figure(figsize=(8, 6))
plt.scatter(time, average_values, label="Measured Recovery", marker='o', s=20)
plt.xlabel("Time (min)")
plt.ylabel("Recovery")
plt.legend()

"""3.8"""

# Perform Min-Max scaling
old_min = min_intensity
old_max = max_intensity

new_min = 0
new_max = 1

scaled_values = ((average_values - old_min) / (old_max - old_min)) * (new_max - new_min) + new_min
normalized_center_intensity = ((center_intensity - old_min) / (old_max - old_min)) * (new_max - new_min) + new_min

display(normalized_center_intensity)

# Transpose scaled_values (convert to a column vector if needed)
scaled_values = scaled_values.reshape(-1, 1)
display(scaled_values[0])

time_scaled = np.array(time)*60

plt.figure(figsize=(8, 6))
plt.scatter(time, scaled_values, label="Normalized Measured Recovery", marker='o', s=20)
plt.xlabel("Time (min)")
plt.ylabel("Recovery")
#plt.title(f"FRAP Recovery Curve (D = {diffusion_coefficient} um^2/min)")
plt.legend()

"""#Simulation

#Set parameters and masks

3.9
"""

# Parameters for the grid and concentration field
grid_size_x = 960  # Number of grid points in x direction
grid_size_y = 728  # Number of grid points in y direction
C_0 = 1.0  # Maximum concentration (at the outermost points)
C_outer = 0.0  # Concentration outside the grid (outside the wall region)
D = 1  # Diffusion coefficient
dx = .9  # Grid spacing in x direction (based on camera)
dt = .1  # Time step
time_steps = 36000  # Number of time steps to simulate

"""#Set Boundary and Masks

3.10
"""

# Wall polygon coordinates
wall_vertices = [(210, 2), (220, 200), (190, 320), (230, 450), (230, 726), (640, 726), (625, 2)]


# Create the initial concentration matrix
C = np.zeros((grid_size_y, grid_size_x))

# Create a polygon path from the wall vertices
wall_path = Path(wall_vertices)

# Create a mask for the region inside the polygon (wall region)
wall_mask = np.zeros((grid_size_y, grid_size_x), dtype=bool)

# Fill the wall_mask with True for points inside the wall
for i in range(grid_size_x):
    for j in range(grid_size_y):
        point = (i, j)
        if wall_path.contains_point(point):
            wall_mask[j, i] = True  # Mark the points inside the wall as True

# Create a mask for the edge of the polygon (boundary points)
boundary_mask = np.zeros_like(wall_mask, dtype=bool)

# Loop through the grid to check if a point is part of the boundary
for i in range(1, grid_size_x - 1):
    for j in range(1, grid_size_y - 1):
        if wall_mask[j, i]:
            # Check if any of the neighboring points are outside the wall
            if (not wall_mask[j+1, i] or not wall_mask[j-1, i] or
                not wall_mask[j, i+1] or not wall_mask[j, i-1]):
                boundary_mask[j, i] = True  # Mark the boundary point

# Calculate concentration inside the grid based on distance from the center (Gaussian profile)
for i in range(grid_size_x):
    for j in range(grid_size_y):
        # If the point is inside the wall region, calculate the concentration
        if wall_mask[j, i]:
            # Calculate the distance from the center of the grid
            r_center = np.sqrt((i - spot_center[0])**2 + (j - spot_center[1])**2)

            # Apply a nested exponential decay based on the distance from the center (inverse profile)
            C[j, i] = normalized_center_intensity+(C_0-normalized_center_intensity)*np.exp((-5*np.exp(-0.5 * (r_center / spot_radius) ** 2)))

            # Ensure the concentration does not exceed C_0 at the outermost points inside the wall
            C[j, i] = min(C[j, i], C_0)

update_mask = wall_mask & ~boundary_mask  # Points inside the wall but not on the boundary# Calling zoom on mask arrays gave weird results, going to regenerate these from scaled vertices

"""#Overlay Simulation and Image

3.11
"""

#Choose the first image to compare with simulation
file_name = f'{base_dir}/{folder_name}/1.tif'
image = tif.imread(file_name)

# Create the plot
fig, ax = plt.subplots(figsize=(10, 10))

# Display the image with the y-axis inverted (origin at bottom-left corner)
ax.imshow(image, cmap='gray', vmin=0, vmax=5000)
ax.invert_yaxis()  # Invert the y-axis so the origin is at the bottom-left

# Plot the wall boundary (polygon) without any additional color fill
#ax.scatter(*zip(*wall_vertices), color='black', label='Wall Boundary')  # Wall vertices
ax.scatter(*zip(*wall_vertices), color='red', label='Wall Boundary')  # Wall vertices
ax.fill(*zip(*wall_vertices), color='red', alpha=0.05)  # Visualize the wall region with low opacity

# Plot the Gaussian profile, aligning it with the dark spot
# The Gaussian profile is overlaid with reduced opacity (alpha) to align it without being too intrusive
ax.imshow(C, cmap='jet', origin='lower', alpha=0.05, vmin=0, vmax=1)  # Slight opacity for better visual effect

circle = patches.Circle(spot_center, spot_radius, edgecolor='w', facecolor='none')
ax.add_patch(circle)

# Display the legend
ax.legend()
plt.title("Wall Boundary with Gaussian Profile")
plt.show()

"""#Rescale Everything

3.12
"""

# RESCALE Everything
SCALE = 0.125  # (new size) = SCALE * (old size)
sigma_scaled = SCALE*spot_radius  # Standard deviation for Gaussian profile
center_x_scaled = SCALE*spot_center[0]
center_y_scaled = SCALE*spot_center[1]
dx_scaled = dx/SCALE # dx should increase as scale decreases
stability = D*dt/(dx_scaled**2)
print('stability = ', stability,'   (must be less than 0.25)')

"""3.13"""

wall_vertices_scaled = [( int(x*SCALE),int(y*SCALE) ) for (x,y) in wall_vertices ]  # unused except for plot
wall_path_scaled = Path(wall_vertices_scaled)

#(grid_size_y_scaled, grid_size_x_scaled) = C_scaled.shape
grid_size_x_scaled = int(SCALE*grid_size_x)
grid_size_y_scaled = int(SCALE*grid_size_y)
wall_mask_scaled = np.zeros((grid_size_y_scaled, grid_size_x_scaled), dtype=bool)
# Fill the wall_mask with True for points inside the wall
for i in range(grid_size_x_scaled):
    for j in range(grid_size_y_scaled):
        point = (i, j)
        if wall_path_scaled.contains_point(point):
            wall_mask_scaled[j, i] = True  # Mark the points inside the wall as True
wall_mask_scaled[0,:]=False   # these weren't getting set correctly after scaling
wall_mask_scaled[-1,:]=False
wall_mask_scaled[:,0]=False
wall_mask_scaled[:,-1]=False

boundary_mask_scaled = np.zeros_like(wall_mask_scaled, dtype=bool)
# Loop through the grid to check if a point is part of the boundary
for i in range(1, grid_size_x_scaled - 1):
    for j in range(1, grid_size_y_scaled - 1):
        if wall_mask_scaled[j, i]:
            # Check if any of the neighboring points are outside the wall
            if (not wall_mask_scaled[j+1, i] or not wall_mask_scaled[j-1, i] or
                not wall_mask_scaled[j, i+1] or not wall_mask_scaled[j, i-1]):
                boundary_mask_scaled[j, i] = True  # Mark the boundary point

update_mask_scaled = wall_mask_scaled & ~boundary_mask_scaled  # Points inside the wall but not on the boundary
C_scaled = np.zeros((grid_size_y_scaled, grid_size_x_scaled))
for i in range(grid_size_x_scaled):
    for j in range(grid_size_y_scaled):
        # If the point is inside the wall region, calculate the concentration
        if wall_mask_scaled[j, i]:
            # Calculate the distance from the center of the grid
            r_center = np.sqrt((i - center_x_scaled)**2 + (j - center_y_scaled)**2)

            # Apply a Gaussian decay based on the distance from the center (inverse profile)
            C_scaled[j, i] = normalized_center_intensity+(C_0-normalized_center_intensity)*np.exp(-5*np.exp(-0.5 * (r_center / sigma_scaled) ** 2))

            # Ensure the concentration does not exceed C_0 at the outermost points inside the wall
            C_scaled[j, i] = min(C_scaled[j, i], C_0)
C_init_scaled = C_scaled.copy()  # save a copy

# Plot the initial concentration field
plt.figure(figsize=(16, 8))
plt.subplot(1,2,1)
plt.imshow(C, cmap='jet', origin='lower', vmin=0, vmax=1)  # Fix the color scale range
plt.colorbar(label='Concentration')
plt.title("ORIGINAL")
plt.scatter(*zip(*wall_vertices), color='white', label='Wall Boundary')  # Wall vertices
#plt.fill(*zip(*wall_vertices), color='black', alpha=0.3)  # Visualize the wall region
plt.legend()

plt.subplot(1,2,2)
plt.imshow(C_scaled, cmap='jet', origin='lower', vmin=0, vmax=1)  # Fix the color scale range
plt.colorbar(label='Concentration')
plt.title("SCALED")
plt.scatter(*zip(*wall_vertices_scaled), color='white', label='Wall Boundary')  # Wall vertices
#plt.fill(*zip(*wall_vertices_scaled), color='black', alpha=0.3)  # Visualize the wall region
plt.legend()


plt.show()

"""##Check Masks

3.14
"""

plt.figure(figsize=(15, 10))

plt.subplot(2,3,1)
plt.imshow(wall_mask)
plt.title('wall_mask original')

plt.subplot(2,3,2)
plt.imshow(boundary_mask)
plt.title('boundary_mask original')

plt.subplot(2,3,3)
plt.imshow(update_mask)
plt.title('update_mask original')

plt.subplot(2,3,4)
plt.imshow(wall_mask_scaled)
plt.title('wall_mask_scaled')

plt.subplot(2,3,5)
plt.imshow(boundary_mask_scaled)
plt.title('boundary_mask_scaled')

plt.subplot(2,3,6)
plt.imshow(update_mask_scaled)
plt.title('update_mask_scaled')

plt.show()

"""#Diffusion

3.15
"""

def diffuse_scaled(C, D, dx, dt, update_mask):
    # Calculate the Laplacian using vectorized operations for interior points
    d2C_dx = (np.roll(C, -1, axis=1) - 2 * C + np.roll(C, 1, axis=1)) / dx**2
    d2C_dy = (np.roll(C, -1, axis=0) - 2 * C + np.roll(C, 1, axis=0)) / dx**2

    # Create a new concentration matrix to apply the updates
    new_C = C.copy()

    # Apply diffusion to the valid points (those inside the wall and not on the boundary)
    new_C[update_mask] += D * dt * (d2C_dx[update_mask] + d2C_dy[update_mask])

    # Ensure the concentration does not go below 0 or exceed C_0
    new_C = np.clip(new_C, 0, C_0)

    return new_C


intensity_curve = []  # To store the recovery curve
C_scaled = C_init_scaled.copy() # reset

for t in range(time_steps):
  #Call our diffuse function which updates our concentration gradient one time step
  C_scaled = diffuse_scaled(C_scaled, D, dx_scaled, dt, update_mask_scaled)

  # Calculate the recovery by averaging the concentration in the bleached region
  recovery = np.sum(C_scaled[(np.arange(grid_size_x_scaled) - center_x_scaled)**2 + (np.arange(grid_size_y_scaled)[:, None] - center_y_scaled)**2 <= sigma_scaled**2])

  # Average over the pixels in the bleached region
  recovery /= np.pi * sigma_scaled**2
  intensity_curve.append(recovery)

# Plot the recovery curve
plt.plot(np.arange(time_steps)*dt, intensity_curve, label="Simulated Recovery")
plt.xlabel("Time (s)")
plt.ylabel("Recovery")
plt.title(f"FRAP Recovery Curve (D = {D} um^2/s)")
plt.legend()
plt.show()

"""3.16"""

# Plot the Final concentration field
plt.figure(figsize=(8, 8))
plt.imshow(C_scaled, cmap='jet', origin='lower', vmin=0, vmax=1)  # Fix the color scale range
plt.colorbar(label='Concentration')
plt.title("Inverted Concentration Field with Wall Region")

# Plot the wall boundary
plt.scatter(*zip(*wall_vertices_scaled), color='white', label='Wall Boundary')  # Wall vertices
#plt.fill(*zip(*wall_vertices), color='black', alpha=0.3)  # Visualize the wall region
plt.legend()
plt.show()

"""##Fit simulation to data

3.17
"""

import numpy as np
import scipy as scipy

# Assuming intensity_curve corresponds to the predicted recovery and scaled_values to the measured data
# You should ensure that the time steps and the measured values are aligned in the same way

scaled_intensity_curve = np.array(intensity_curve)

# Make sure to interpolate the intensity_curve for the time points of the measured data (time)
interpolated_curve = np.interp(time_scaled, np.arange(len(scaled_intensity_curve))*dt, intensity_curve)

# Calculate the R² value between the interpolated intensity curve and the measured recovery points
slope, intercept, r_value, p_value, std_err = scipy.stats.linregress(interpolated_curve, scaled_values.flatten())
r_squared = r_value**2

print(f"R² Value: {r_squared}")

plt.figure(figsize=(8, 6))
plt.scatter(time_scaled, scaled_values, label="Normalized Measured Recovery", marker='o', s=20)
plt.plot(np.arange(time_steps)*dt, scaled_intensity_curve, label="Simulated Recovery")
plt.show()